    GitHub 是一个面向开源及私有 软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。
    
    git clone 版本库地址 //把版本库从远程复制到本地 
    git remote -v //查看远程版本库地址 
    git status //查看git状态 
    git add .修改的文件 // .：全部文件 =>某个文件  (从红色状态变绿)
    git commit -m '提交的描述信息' 
    git push //提交远程版本库 
    Git pull //拉取远程版本库

    Object.defineProperty

--------------------------------------------------------------------------------------------------------

    @click  v-on:click.stop = "指令表达式 1+1  2指令的value"
        v-on : 指令名
        click: 指令参数
        stop : 指令修饰符(修饰符可以链式使用)

    click修饰符
        .stop === stopPropagation
        .prevent === preventDefault
        .capture 
        .once
        .self  点击自身

        .capture和.self的区别：
            .capture先执行父级的函数，再执行子级的触发函数(一般用法),即是给元素添加一个监听器,当元素发生冒泡时,先触发带有该修饰符的元素.若有多个该修饰符,则由外而内触发.
            .self是只执行子级本身的函数

    model修饰符
        v-model  
        .number   转换为数字类型
        .lazy  默认input事件触发、  =》 change触发
        .trim  格式、把前后空格去掉

    键盘修饰符
        数字     keyCode
        .enter   keyName

    事件对象 ： 用$event来传递

    var a = Vue.set(arr,0,'xyz');
    Vue.set = this.$set
    全局的set方法    
        Vue.set(vm.obj, key, newValue)；
    实例的$set方法  
        this.$set(this.arr,下标,newdata)

    splice();   参数：起始位置，长度，value

    Object.assign    es6新增，对象深拷贝
        Object.assign({}, vm.obj, newObj);
    1、复制时新创建的对象
    2、3、要合并在一起的对象
    vm.obj = Object.assign({}, vm.obj, newObj);

    计算属性缓存(computed)和方法(methods)的区别:
        计算属性是基于它们的响应式依赖进行缓存的只在相关响应式依赖发生改变时它们才会重新求值.相比之下，每当触发重新渲染时,调用方法总是会再次执行函数
        
    computed:   
        computed 是个函数返回值 必需有data参与 一定注意使用场景
        computed是由get、set两个钩子函数定义的
        computed直接定义函数是get的一个简写形式,是由get和set两个钩子函数定义的(set有一个参数来接收computed修改的值)
        computed展开写法:
        he:{
            get(){// 没有返回值
                // return 表达式
                eg:return this.jiashu1 + this.jiashu2 // 直接返回
            },
            set(value){//有返回值
                console.log(value)
                eg:this.jiashu1 = value
            }
        }

    watch:watch 可以监听 data和computed
        如果要监听对象某个key值，obj.key
        deep:true属性能深度检测到对象的改变，默认false
        vue实例方法$watch,,是没有全局方法的
        
        在vue实例外侦听语法：Vue.$watch(expOrFn,callback,[options])
            vm.$watch('obj.a',function(new,old){},{
                deep:true,
            })
        $watch可以监听一个函数，其实是监听了函数的返回值

            watch展开式写法
        侦听data
        watch 的监听直接定义函数其实是handler简写
    (1) he:{
            handler(newvalue,oldvalue){
                console.loog('he change)
            }
        }

        侦听对象
        如果要监听对象的某个key值  obj.key
    (2) 'obj.a': function(v){
            console.log(v);
        },

---------------------------------------------------------------------------------------------------

    全局方法 directive 要写在vue实例的前边
    Vue.directive('指令名',function(){});
    1、指令名 on show if    加 'v-'
        abc   v-abc
    2、钩子函数
        指令是通过一些规则来操作dom的

        钩子函数的参数：
        1.钩子函数的第一个参数是dom对象(原生dom对象) el
        2.钩子函数第二个参数  binding

        指令名、指令参数、指令修饰符、指令表达式、指令的值
        name     arg     modifiers  expression   value

binding的参数：name arg modifiers expression value

    钩子函数拆分写法的函数：
    bind()   inserted()  update()
    unbind()  componentUpdated()

    如果定义的指令参数是一个回调函数，
    那表示bind和update的简写

    全局注册指令 在vue挂载点的任何地方可以使用
        Vue.directive('color',function(el,binding){
            console.log(1);
            el.style.color= binding.value;
        });
    拆分式写法：
        Vue.directive('color',{
            bind(el,binding,vnode,oldvnode){
                console.log(vnode);
                el.style.color= binding.value;
            },
            inserted(el,binding){

            },
            update(el,binding){
                el.style.color= binding.value;
            }
        });
    
    模拟一个v-cloak
        Vue.directive('cloak1',{
            bind(el,binding){
                el.setAttribute(binding.rawName,'')
            }
        });

-------------------------------------------------------------------------------------------------------

    Vue.filter 过滤

    过滤一条data、computed
    Vue.filter   Vue.directive
    过滤器  | （管道符）
        computed 与 filter 的区别
    filter可以动态传入过滤内容
    filter的使用场景： 如果大量数据需要同一种规则改变的话使用
        Vue.filter('phone',function(val,arg1){
            return val + (arg1 ||'****') + 678;
        });

    filter使用的地方
    {{}}   /  动态bind的引号里 
        1. {{data | filter}}
        2. :abc="data | filter"

    filter可以传参
    data | filtername('filterArg1','filterArg2',...)
    接受参数就是通过filter的第二参数，依次类推
    第一个参数是要过滤的值

    Vue.component
    组件注册
    Vue.component('test',{
        template:`<h1>{{title}}</h1>`,
        data(){
            return {
                msg:this.title
            }
        },
        props:['title'],
    });

    组件之间的传值
        父组件与子组件
            谁使用了组件，谁就是父组件，被使用的就是子组件。
        父组件向子组件传值
            1、子组件需要同意： props
            2、父组件如何通过props传入值
        props: ['自定义属性名']

        子组件怎么告诉父组件做了什么?
            $emit(自定义事件)
            1、子组件向父组件发送自定义事件
            2、父组件需要监听子组件的事件
        $emit('自定义事件名',事件参数) 
    
    $event 来接受事件参数
    v-model (语法糖)  ==   :value + @input

-------------------------------------------------------------------------------------------------

    组件插槽 slot
    具名插槽 slot  name
        v-slot:插槽名 （template or component）
    默认插槽，未指定名字的内容都会统一放入到默认插槽里
    默认插槽 默认名字：default

    动态组件  <component> 
    <component> 通过is=“组件名||组件的选项对象”属性指向组件